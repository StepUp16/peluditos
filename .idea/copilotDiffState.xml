<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/veterinaria/peluditos/data/UsuarioDao.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/veterinaria/peluditos/data/UsuarioDao.java" />
              <option name="originalContent" value="package com.veterinaria.peluditos.data;&#10;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.room.Dao;&#10;import androidx.room.Insert;&#10;import androidx.room.OnConflictStrategy;&#10;import androidx.room.Query;&#10;&#10;import java.util.List;&#10;&#10;@Dao&#10;public interface UsuarioDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    void insert(Usuario usuario);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios&quot;)&#10;    LiveData&lt;List&lt;Usuario&gt;&gt; getAllUsuarios();&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE uid = :uid&quot;)&#10;    LiveData&lt;Usuario&gt; getUsuario(String uid);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE uid = :uid&quot;)&#10;    Usuario getUsuarioSincrono(String uid);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE email = :email LIMIT 1&quot;)&#10;    LiveData&lt;Usuario&gt; getUsuarioByEmail(String email);&#10;&#10;    @Query(&quot;DELETE FROM usuarios WHERE uid = :uid&quot;)&#10;    void deleteUsuario(String uid);&#10;&#10;    // Obtener usuarios no sincronizados (offline changes)&#10;    @Query(&quot;SELECT * FROM usuarios WHERE sincronizado = 0 ORDER BY timestampModificacion DESC&quot;)&#10;    List&lt;Usuario&gt; getUsuariosLocales();&#10;&#10;    // Actualizar estado de sincronizaci贸n&#10;    @Query(&quot;UPDATE usuarios SET sincronizado = :sincronizado WHERE uid = :uid&quot;)&#10;    void actualizarSincronizacion(String uid, boolean sincronizado);&#10;&#10;    // Actualizar el ID de un usuario local con su nuevo ID de Firebase&#10;    @Query(&quot;UPDATE usuarios SET uid = :nuevoUid WHERE uid = :viejoUid&quot;)&#10;    void actualizarUid(String viejoUid, String nuevoUid);&#10;&#10;    // Marcar un usuario como modificado offline&#10;    @Query(&quot;UPDATE usuarios SET sincronizado = 0, timestampModificacion = :timestamp WHERE uid = :uid&quot;)&#10;    void marcarComoModificadoOffline(String uid, long timestamp);&#10;&#10;    // Verificar si hay cambios pendientes de sincronizaci贸n&#10;    @Query(&quot;SELECT COUNT(*) FROM usuarios WHERE sincronizado = 0&quot;)&#10;    int getCantidadCambiosPendientes();&#10;&#10;    // Limpiar usuarios locales duplicados&#10;    @Query(&quot;DELETE FROM usuarios WHERE uid LIKE 'local_%' AND EXISTS (SELECT 1 FROM usuarios u2 WHERE u2.dui = usuarios.dui AND u2.uid NOT LIKE 'local_%')&quot;)&#10;    void limpiarUsuariosLocalesDuplicados();&#10;}&#10;" />
              <option name="updatedContent" value="package com.veterinaria.peluditos.data;&#10;&#10;import androidx.lifecycle.LiveData;&#10;import androidx.room.Dao;&#10;import androidx.room.Insert;&#10;import androidx.room.OnConflictStrategy;&#10;import androidx.room.Query;&#10;&#10;import java.util.List;&#10;&#10;@Dao&#10;public interface UsuarioDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    void insert(Usuario usuario);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios&quot;)&#10;    LiveData&lt;List&lt;Usuario&gt;&gt; getAllUsuarios();&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE rol = 'cliente'&quot;)&#10;    LiveData&lt;List&lt;Usuario&gt;&gt; getAllClientes();&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE uid = :uid&quot;)&#10;    LiveData&lt;Usuario&gt; getUsuario(String uid);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE uid = :uid&quot;)&#10;    Usuario getUsuarioSincrono(String uid);&#10;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE email = :email LIMIT 1&quot;)&#10;    LiveData&lt;Usuario&gt; getUsuarioByEmail(String email);&#10;&#10;    @Query(&quot;DELETE FROM usuarios WHERE uid = :uid&quot;)&#10;    void deleteUsuario(String uid);&#10;&#10;    // Obtener usuarios no sincronizados (offline changes)&#10;    @Query(&quot;SELECT * FROM usuarios WHERE sincronizado = 0 ORDER BY timestampModificacion DESC&quot;)&#10;    List&lt;Usuario&gt; getUsuariosLocales();&#10;&#10;    // Actualizar estado de sincronizaci贸n&#10;    @Query(&quot;UPDATE usuarios SET sincronizado = :sincronizado WHERE uid = :uid&quot;)&#10;    void actualizarSincronizacion(String uid, boolean sincronizado);&#10;&#10;    // Actualizar el ID de un usuario local con su nuevo ID de Firebase&#10;    @Query(&quot;UPDATE usuarios SET uid = :nuevoUid WHERE uid = :viejoUid&quot;)&#10;    void actualizarUid(String viejoUid, String nuevoUid);&#10;&#10;    // Marcar un usuario como modificado offline&#10;    @Query(&quot;UPDATE usuarios SET sincronizado = 0, timestampModificacion = :timestamp WHERE uid = :uid&quot;)&#10;    void marcarComoModificadoOffline(String uid, long timestamp);&#10;&#10;    // Verificar si hay cambios pendientes de sincronizaci贸n&#10;    @Query(&quot;SELECT COUNT(*) FROM usuarios WHERE sincronizado = 0&quot;)&#10;    int getCantidadCambiosPendientes();&#10;&#10;    // Limpiar usuarios locales duplicados&#10;    @Query(&quot;DELETE FROM usuarios WHERE uid LIKE 'local_%' AND EXISTS (SELECT 1 FROM usuarios u2 WHERE u2.dui = usuarios.dui AND u2.uid NOT LIKE 'local_%')&quot;)&#10;    void limpiarUsuariosLocalesDuplicados();&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>